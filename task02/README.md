# Условие
Вам необходимо написать скрипт, который находит дубликаты файлов в заданном каталоге (папке),
а также автоматические unit и/или end-to-end тесты для него.

# Подробнее
## Скрипт
Скрипт с именем `find_duplicates.py` получает в качестве единственного параметра командной строки имя каталога.
Требуется обойти рекурсивно этот каталог и найти все файлы с побайтово одинаковым содержанием.
Файлы, имена которых начинаются с `.` или `~`, должны игнорироваться<sup>[1](#ignores)</sup>.

Каждая строка в выводе скрипта должна содержать имена одинаковых файлов, разделенные двоеточием
или разделителем, принятым для переменной `PATH` на операционной системе (точка с запятой для Windows).
Если содержимое какого-либо файла никем не дублируется, то выводить его не нужно.

Элементы выводимых путей должны разделяться либо прямыми слэшами `/`, либо слэшами,
используемыми на операционной системе (обратные слэши на Windows, прямые на Linux).

Время работы программы на каталоге, не содержащем дубликатов, не должно превышать
`O(n+s)`, где `n`- количество файлов и папок в каталоге, а `s` - суммарный размер
всех неигнорируемых файлов.

При выполнении задания окажутся полезными модули `sys`, `os`, `os.path` и `hashlib`.
Запрещается читать файл в память целиком, размер блока чтения нужно выбрать
самостоятельно и обосновать свой выбор в комментариях в решении.

### Лирическое отступление
Файловая система - это сложно.

<a name="ignores"><sup>[1]</sup></a>: строго говоря, игнорирование файлов с именами
`.*` и `~*` - это конвенция Linux (которая хорошая тем, что работает на почти всех
файловых системах).
Под Windows же стандартная конвенция - ставить у файла атрибут "скрытый".
К сожалению, Python не поддерживает простую проверку этих атрибутов "из коробки" и
больше ориентирован на Linux.

Также есть и другие ситуации, в которых разумно обрабатывать файлы по-другому,
но мы их в этом задании опускаем для простоты:

* Точки монтирования в Linux (вроде `/mnt/sdb1`) может быть разумно полностью пропускать.
  Или не пропускать.
* Жёсткие ссылки (hard links) может быть разумно учитывать только один раз при подсчёте.
  Более того, жёсткие ссылки можно детектировать ещё до чтения содержимого файла.
* Символические ссылки (в Linux) и точки соединения NTFS (в Windows) может быть разумно:
    * Игнорировать
    * Учитывать, только если они указывают на файлы/папки вне каталога поиска
    * Учитывать всегда
    * Обрабатывать по-разному в зависимости от параметров запуска

Более того, если в Linux символические ссылки и точки монтирования - обычное дело,
то в Windows обычно встречаются только точки соединения NTFS (похожи на символьные ссылки),
да и то редко.

## Пример
Пусть у нас есть следующая иерархия:
* `top_dir/`
	* `file1`
	* `file2`
        * `.hidden`
	* `dir1/`
		* `file1`
		* `file3`
	* `dir2/`
		* `file1`
		* `file3`
		* `.hidden`

Мы передаем `top_dir` в качестве параметра командной строки скрипту:

    ./find_duplicates.py top_dir

Кроме того, считаем, что файлы с одинаковым именем (`file1`, `file2` или `file3`)
имеют одинаковое содержимое, тогда вывод программы может быть следующим:

	file1:dir1/file1:dir2/file1
	dir1/file3:dir2/file3

Порядок строк и порядок файлов внутри строк не важен.
Имена файлов могут выводиться либо как в примере, относительно `top_dir` (не включая ее и без слэша в начале),
либо в виде абсолютного пути.
Обратите внимание, что `file2` есть только в одном экземпляре, поэтому в результате программы он отсутствует.
Имя файла `.hidden` начинается с точки, поэтому в выводе программы он также отсутствует.

При запуске на Windows также допустимым выводом является

	file1;dir1\file1;dir2\file1
	dir1\file3;dir2\file3

Но не

	file1;dir1\file1;dir2\file1
	dir1/file3:dir2\file3

## Тесты
Автоматические тесты требуется реализовать в отдельном файле
`test_find_duplicates.py` с использованием pytest.
Вам следует тщательно тестировать ваш скрипт на соответствие условию.
Рекомендуется тестировать отдельные процедуры, однако вы также можете
тестировать решение целиком (end-to-end).

Требуется, чтобы добавлению любого из дефектов ниже в ваше решение ломало хотя бы один тест:

1. Неверный формат вывода на ваш выбор: например, использование `;` вместо `:`
2. При поиске дубликатов учитывается файл с именем, начинающимся на `.` или `~`
3. Все файлы одного размера считаются одинаковыми
4. Все файлы с одинаковым именем считаются одинаковыми

При оценке стиля кода также будет учитываться качество ваших тестов.
Постарайтесь так разделить скрипт на процедуры, чтобы непротестированные
участки кода были тривиальны: либо точно всегда работает, либо не работает никогда.

Вам могут пригодиться fixture под названием `tmpdir`, `capsys`.

## Требования к корректности решения
Если присланные файлы не соответствуют хотя бы одному из условий ниже,
решение считается некорректным и оценивается в 0 баллов:

* Должны отсутствовать синтаксические ошибки для Python 3
* `pycodestyle` при запуске без флагов не должен выдавать ошибок и предупреждений
* Запрещается вызывать внешние команды вроде `find`, `ls`, `dir`, `md5sum` и прочие
  * Причина: они отличаются между ОС вроде Windows/Linux/MacOS
* Реализовано хотя бы три автоматических теста при помощи pytest или doctest
* Ваша реализация проходит все ваши автоматические тесты
* Ваши автоматические тесты не зависят от деталей реализации Python, например,
  от порядка элементов при итерированию по `dict`

# Формат сдачи
* К письму прикрепите файлы `find_duplicates.py` и `test_find_duplicates.py`
* Запрещается добавлять код на верхний уровень файла `find_duplicates.py`,
   за исключением объявлений процедур и функций.

# Сроки сдачи
|   | `18.Б09-пу` | `18.Б10-пу` |Максимальное количество баллов при сдаче в срок
|---|---|---|---|
|Дата занятия|Среда, 20.02.2019|Понедельник, 18.02.2019|   |
|Мягкий дедлайн|Среда, 27.02.2019, 13:40|Воскресенье, 25.02.2019, 22:59|3|
|Жёсткий дедлайн|Вторник, 05.03.2019, 22:59|Воскресенье, 03.03.2019, 22:59|1.5|
