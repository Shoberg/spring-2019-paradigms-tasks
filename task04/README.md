# Общее
Это домашнее задание состоит из двух задач, в которых вы будете писать кусок
интерпретатора искусственного языка программирования "ЯТЬ".
Баллы за вторую задачу выставляются только при корректном решении первой.

Первая задача оценивается в 1 балл, вторая задача оценивается в 4 балла.
По каждой задаче 50% вы получаете за корректность и ещё 50% за стиль кода.

Обе задачи требуется реализовать на базе имеющихся файлов `model.py` и `test_model.py`.

# Задача 1: Scope
Требуется реализовать класс `Scope`, который хранит информацию о значениях переменных
в определённой _динамической_ области видимости и предоставляет к ним доступ по имени переменной.
Области видимости могут вкладываться: при отсутствии переменной в текущей области видимости `Scope`
должен рекурсивно запросить переменную у родительской области видимости.

## Пример
```
a, b, c = object(), object(), object()
parent = Scope()
parent['foo'] = a
parent['bar'] = b
scope = Scope(parent)
ans = scope['bar'] # ans is b
ans = parent['bar'] # ans is b
scope['bar'] = c
ans = scope['bar'] # ans is c
ans = parent['bar'] # ans is b
ans = scope['foo'] # ans is a
ans = scope['zoo'] # KeyError
```

## Подробнее
* В `Scope` будут храниться именованные константы и функции (реализованные в следующей задаче), однако реализация не должна от этого зависеть.
* `Scope` может иметь родителя, который передаётся как опциональный параметр конструктора.
* Если при поиска искомая переменная не содержится в текущем `Scope`, поиск должен делегироваться родителю.
* Если искомая переменная отсутствует во всей иерархии `Scope`, должно возбуждаться исключение `KeyError`
  с именем переменной в качестве параметра: `raise KeyError(var_name)`.
* `Scope` должен поддерживать dict-like интерфейс доступа при помощи методов `__getitem__` и `__setitem__`.
* Поддерживать удаление переменных не требуется.

## Тесты
Требуется проверить поведение `Scope` как минимум в трёх случаях:
1. Переменная находится в текущем `Scope`.
2. Переменная находится в прародительском `Scope`.
3. Переменная отсутствует в иерархии `Scope`.

## Требования к корректности решения
Если присланные файлы не соответствуют хотя бы одному из условий ниже, решение считается некорректным и оценивается в 0 баллов:

* Должны отсутствовать синтаксические ошибки для Python 3
* `pycodestyle` при запуске без флагов не должен выдавать ошибок и предупреждений
* Все ваши автоматические тесты должны проходить
* `Scope` реализует методы `__getitem__` или `__setitem__`
* Сигнатура конструктора `Scope` оставлена без изменений

# Задача 2: ЯТЬ
Требуется реализовать набор классов, описывающих элементы [абстрактного синтаксического дерева](https://en.wikipedia.org/wiki/Abstract_syntax_tree) языка ЯТЬ:
* `Number`
* `Function`
* `FunctionDefinition`
* `Conditional`
* `Print`
* `Read`
* `FunctionCall`
* `Reference`
* `BinaryOperation`
* `UnaryOperation`

В языке есть всего два типа: целые числа (`Number`) и функции (`Function`).
Эти классы и обозначают константу в исходном коде программы,
и используются интерпретатором для хранения промежуточных вычислений.

Все конструкции языка ЯТЬ являются выражениями, т.е. их можно вычислить
при помощи метода `evaluate` и получить в результате либо число, либо функцию.

Все классы наследуются от абстрактного базового класса `ASTNode`,
который дан в `model.py`.

## Пример
```
operation1 = FunctionDeclaration("foo", Function(["a", "b"],
  [
    Print(BinaryOperation(Reference("a"), "+", Reference("b"))),
  ]
))
operation2 = FunctionCall(Reference("foo"), [
    Number(1),
    BinaryOperation(Number(2), "+", Number(3))
])
s = Scope()
operation1.evaluate(s)
operation2.evaluate(s)  # 6
```

## Подробнее
* Считайте, что в программе, которую нужно вычислить, нет ошибок, например:
  * Результат вычисления выражения `fun_expr`, переданного в качестве параметра конструктору `FunctionCall`, всегда будет объект `Function`
  * Результатами вычисления `lhs` и `rhs` параметров `BinaryOperation` всегда будет `Number`
  * Результатом вычисления выражения параметра `Print` всегда будет `Number`
  * Все используемые имена всегда объявлены
* Шаблоны класса и примеры использования описывают минимальные требования к интерфейсу классов, вы можете расширять их по своему усмотрению или определять дополнительные классы, не указанные в списке.
* Не изменяйте имена классов и имена, список и порядок параметров и возвращаемые значения обязательных методов.
* В программе могут встречаться анонимные функции: например, просто узел `Function`.
* Обратите внимание, что в языке ЯТЬ используется динамическая область видимости (как в Bash), а не лексическая (как в Python, Java, C++ и других языках) - её проще реализовать

## Тесты
Требуется при помощи pytest:

1. Для каждого класса, кроме `Number`, `Function`, проверить его поведение хотя бы одним независимым тестом.
2. Проверить корректность интерпретатора end-to-end, написав вычисление факториала при помощи рекурсивной функции на языке ЯТЬ.

## Требования к корректности решения
Если присланные файлы не соответствуют хотя бы одному из условий ниже, решение считается некорректным и оценивается в 0 баллов:

* Должны отсутствовать синтаксические ошибки для Python 3
* `pycodestyle` при запуске без флагов не должен выдавать ошибок и предупреждений
* Все ваши автоматические тесты должны проходить
* Все требуемые в задании классы должны наследоваться от `ASTNode`
* Сигнатуры конструкторов и методов `evaluate` оставлены без изменений

# Формат сдачи
* К письму прикрепите файл `model.py` с реализацией классов и файл `test_model.py` с автоматическими тестами на pytest.
* Запрещается добавлять код на верхний уровень всех файлов, за исключением объявлений процедур, функций, констант, классов и импортов.

# Сроки сдачи
|   | `18.Б09-пу` | `18.Б10-пу` |Максимальное количество баллов при сдаче в срок
|---|---|---|---|
|Дата выдачи|Среда, 06.03.2019|Среда, 06.03.2019|   |
|Мягкий дедлайн|Среда, 13.03.2019, 22:59|Среда, 13.03.2019, 22:59|5|
|Жёсткий дедлайн|Среда, 20.03.2019, 22:59|Среда, 20.03.2019, 22:59|2.5|
